# 空间配置器

## 一.空间配置器概述

STL的操作对象都放在容器内，而容器需要一定的配置空间来存放数据资料，而空间配置器就负责给容器分配空间，SGI STL分配的空间是内存（其实基本都是内存吧）。

## 二.空间配置器的标准接口

### 1.必要接口

根据容器的需要和STL的规范，一个空间配置器必须有一些必要接口，如值类型，值指针，size_type，rebind，还有一些函数，如分配空间，构造，取地址，获得最大空间等。

### 2.一个简单的空间配置器

书中提供了一个很简单的空间配置器，这个空间配置器就提供了rebind，分配空间，销毁空间，构造析构，取地址，获得最大空间这些功能，但是具体容器怎么使用，怎么分配空间怎么构造自身，这个还要看后面的知识和容器的源码。

这段代码不难，这里添加一点知识辅助看懂：

[C++的一些基本知识](https://github.com/wasamtc/C-Basics)

## 三.具备次配置力的SGI空间配置器

虽然SGI STL有一个std::allocator，但是效率不咋地，一般不用。

SGI STL真正用的空间配置器主要有以下部分：
<stl_construct.h> ：定义了全局函数中的construct和destroy函数，负责对象的构造和析构，这个文件中的类是符合STL标准规范的。

<stl_alloc.h>：这个文件里面定义了一二级配置器，用于空间的分配和释放。

<stl_uninitialized.h>：定义了一些全局函数，用来填充或复制大块内存数据，符合STL标准规范。

### 1.<stl_construct.h>

这个文件的结构是这样的，首先是构造函数construct，这个设计的很平常就那样，没什么好说的。

然后是析构函数destroy：

destroy设计了两个基本版本，一个是单纯的析构一个对象，另一个是析构两个迭代器中的所有对象，第一个没啥好说的，关键是第二个，因为有的类型的对象析不析构都无所谓（例如有的析构函数啥也没写），在这种无所谓的情况下如果我们析构了很多对象就会降低效率，所以我们用value_type()得到对象的类别，进一步设计_destroy函数，这个函数中用 __type_traits判断该类型的析构是否无关紧要，然后根据得到的类型用 _destroy_aux函数（有两个，函数重载，分别处理两种情况）处理，如果有所谓就一个一个析构，无所谓就空，啥也不干。

还有针对第二个基本版本的destroy的两个特化，char*和 wchar_t *的

### 2.<stl_alloc.h>

为什么SGI STL要采取两级配置呢，主要是考虑到内存碎片（我觉得主要是外部碎片），第一级配置器直接用malloc和free分配和释放内存，第二级配置根据情况采取策略，当要配置的区块超过128bytes时，视之为足够大，用第一级配置器，否则用第二级配置器，至于是开放设计第一级还是同时开放两级，看__USE_MALLOC常量，若为真则只有第一级。

之前说过alloc并不符合STL 标准规范，所以我们会为其包装一个simple_alloc的接口，这个接口符合STL规格，只是单纯的转调用而已。

PS：其实我还有一个问题，就是怎么调用那个构造和析构函数的，不过这个可能要看后面的代码才看得出来 //待完善
