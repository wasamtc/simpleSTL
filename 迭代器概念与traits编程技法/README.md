# 迭代器概念与traits编程技法

迭代器定义：提供一种方法，使之能够依序巡防某个聚合物（容器）所含的各个元素，而又无需暴露该聚合物的内部表述方式

## 一.迭代器设计思维—STL关键所在

STL中心思想在于将容器与算法分开，彼此独立设计然后用迭代器将两者撮合在一起，算法可以通过迭代器访问容器。

## 二.迭代器是一种smart pointer

开始先介绍了一个auto_ptr（这个和智能指针好像差不多），auto_ptr可以在离开作用域的时候自动销毁从而避免造成内存泄漏，实现方式就是把指针封装在一个auto_ptr类中，析构函数为delete，迭代器也可以借鉴auto_ptr的设计方式，封装一个相应类型的指针在类中，然后设计相应的函数使这个类表现的像个指针（主要是重载），后面设计了一个用于list的find的迭代器，这个迭代器也是只能给list用，而且单独在外面设计的话暴露了list太多的信息，还不如就在list里面设计，所以我们看到的迭代器都是专门设计在每一种STL容器的里面。

我觉得要理解迭代器很关键的一点就是迭代器的表现像指针，但这种相似是通过封装了指针以及许多函数的模板类实现的。

## 三.迭代器相应类别

假如设计好了迭代器，但是有一个问题，如何“以迭代器所指对象的型别”作为型别，如果我们定义了一个容器，然后用星号去取迭代器所指内容，得到的是值而不是型别，这里我们用的是模板函数的自动推导，即

```C++
template<typename T1, typename T2>
void func_impl(T1 iter, T2 t)
{
    T2 temp;
    // ......
}

template<typename T>
void func(T iter)
{
    func_impl(iter, *iter);
}
```

func是一个使用迭代器所指型别的接口，这样传参func_impl中的T2就是迭代器所指型别了。

与迭代器有关的型别不只有迭代器所指对象的型别这一种，还有许多其他的无法用这种参数推导的方式获得，所以我们需要更加全面的解法。
