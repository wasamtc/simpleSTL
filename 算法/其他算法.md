# 其他算法

## 一.单纯的数据处理

这一小节所列的算法都是很简单的关于数据的算法，都是对数据做一些基本的操作。

### adjacent_find（查找相邻而重复的元素）

算法找出第一组满足条件（相等或自设条件）的相邻元素。

### count（计数）

将迭代器所指区间的每一个元素拿来和指定值比较并计数。

### count_if（在特定条件下计数）

提供一个条件进行计数。

### find（循序查找）

循序查找到第一个符合条件的元素位置。

### find_if（循序查找符合特定条件者）

提供一个特定条件，循序找到第一个符合的元素位置。

### find_end（查找某个子序列的最后一个出现点的首位置）

提供两个序列，在序列一中查找序列二的最后一次出现点，可以自行提供函数。

注意，找的是序列二出现的最后一块地方的第一个位置，不是末尾位置。

因为迭代器型别不同可以采用不同的查找方法，所以这里也是通过提取迭代器特性和函数重载实现多个函数。

这里分为两个函数，一个是forward iterators版，一个是bidirectional iterators版，后一个用到了逆向迭代器，以后看第8章的时候再说。

### find_first_of（查找某些元素的最初出现点）

在序列一中查找序列二种任一元素第一次出现的位置，只要是序列二中任何一个元素出现都行。这是一个O(n^2)的算法。可以自行传递函数。

### for_each（对区间内的每一个元素实行某操作）

传入一个区间和一个函数，对区间内的每一个元素实行函数操作，但是该函数不能改变元素内容。

### generate（以特定操作之结果覆盖序列内的每个元素）

传入一个特定操作，对每个元素使用*first = gen()，注意，这个不算是对每一个元素执行操作，因为这个并没有以每个元素作为参数，而是单纯地对每一个元素执行某一个特定操作，且规定函数操作本身不得有任何参数。

### generate_n（以特定操作之结构覆盖序列内前n个元素）

和上一个差不多，不过上一个是每个元素，这个是前n个元素。

### includes（是否涵盖于某序列之中）

特别注意，此算法应用于有序区间。

判断序列二中的每一个元素是否出现于序列一，如果序列二有m个相同元素，那么序列一必须有不少于m个的该元素。

有两个版本，第一个版本默认以less升序来判断相同，第二个版本自行传入函数，不过该函数要能表示相等且符合具体的序列情况，即如果序列是升序的话就要用默认的less，如果是降序的话就要用greater。

### merge（合并两个序列）

特别注意，此算法应用与有序区间。

将两个有序序列合并至另一序列，合并的结果也是有序的。有两个版本，第一个用于升序，第二个版本可执行传入函数，不过原序列为降序的话最好还是传入greater。

### min_element（最小值所在位置）

找到序列中最小值所在的位置，有两个版本，可自行传入函数。

### partition（分割）

算法将符合条件的元素移至前端，将不符合条件的元素移至后端，这是通过不断的在前端后端找要交换的元素交换实现的（这个就是快排的那个）。

算法不保证保留元素的原始相对位置，有一个stable_partition可以保留原始相对位置。

### remove（移除但不删除）

移除序列中所有与value相等的元素，不删除的意思是容器的大小并未改变，不等于value的元素依次放在first及之后的空间。也就说没有任何元素被删除，只有不与value相等的元素覆盖了前面的元素，所以会剩下残余元素，返回一个指向第一个残余元素的迭代器，可以用erase函数去掉后面的残余元素，remove函数是调用了remove_copy函数。

array不能用remove和remove_if，因为array的残余元素不能被去掉。

### remove_copy（移除某类元素并将结果放到另一容器）

原序列不变，将所有不与value相等的元素放到另一容器中，这个容器可以是自身。

### remove_if（移除符合特定条件的元素）

移除符合特定条件的元素，也存在残余元素问题。

### remove_copy_if（移除符合特定条件的元素并将结果放到另一容器中）

和前面差不多，不过如果要以自身为另一容器，有可能会超出自身大小界限。

### replace（替换某类元素）

将区间内所有old_value以new_value覆盖代替。

### replace_copy（替换某类元素，将得到的序列复制到新容器）

和replace的行为类似，不过是把新序列复制到另一容器。

### replace_if（替换符合特定条件的元素）

自行传入条件pred，符合条件的被替换为new_value。

### replace_copy_if（替换符合特定条件的元素，并复制到新容器）

就那意思。

### reverse（反转元素次序）

将序列的元素在原容器内反转，与迭代器特性有关，所以还是设计成双层架构。有bidirectional iterator版，还有random access iterator版。

### reverse_copy（反转元素次序，并复制到新容器）

实现方式和reverse基本没有什么关联哦，只有一个版本。

### rotate（旋转）

将[first，middle)内的元素和[middle，last)内的元素互换。与迭代器移动能力有关，还是设计成双层架构。

共有三个版本：

forward iterator：就前段、后段的元素一一交换，如果有没交换完的继续重复。

bidirectional iterator：先反转前段，再反转后段，再反转整体。

random access iterator：这个算法我不是很理解，但是实践了一下好像很厉害。可以看资料。

参考：

[STL源码之rotate函数结合图和实例分析](https://blog.csdn.net/freeelinux/article/details/54021655)

[__rotate_cycle函数详解](https://blog.csdn.net/liziyun537/article/details/6025266)

### rotate_copy（旋转并复制到新容器）

实现超级简单，先把后段复制到新容器，再把前段接续复制到新容器。

### search（查找某个子序列的首个出现点）

在序列一中查找序列二的首个出现点，代码逻辑比较简单，比较有意思的是find_end调用了search函数，并在外面加了层循环，这样就可以找到最后一个出现块的首个出现点了。

### search_n（查找连续符合特定条件n次的子序列起点）

在序列中查找连续符合特定条件（默认是与传入值相等）n次的子序列起点，有两个版本，第一个是默认版本，第二个是自行传递函数，代码逻辑比较简单。

### swap_ranges（交换）

功能更弱但效率更高的rotate，交换两个序列，序列一长度不大于序列二。当然，其实这个函数挺容易写，其实都不用调用自己都能写。

### transform（两个序列交互产生新序列）

有两个版本，第一个不需要两个序列，就是操作序列一的每个元素然后把结果放入新序列。第二个需要两个序列，用二元操作得到新结果放入新序列。

### unique（移除重复元素）

移除序列中的重复元素，存在残余元素，特别注意，unique只能移除相邻的重复元素，如果想移除不相邻的重复元素，要先排序。有两个版本，第二个版本是自行定义的相等函数。这个是先用adjacent找到相同元素起点，再调用unique_copy。

### unique_copy（移除重复元素得到新序列放入新容器）

代码还是比较简单，也有两个版本，第二个是自行定义的相等。
