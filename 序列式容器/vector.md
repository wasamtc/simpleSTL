# vector

## 一.vector概述

vector的数据安排及操作方式类似于array，但是array是静态空间，而vector是动态空间，随着元素的加入它的内部会自动扩充空间。

vector的实现关键在于对大小的控制和对重新配置时的数据移动效率。

## 二.vector定义摘要

这个定义摘要倒没什么好说的，就是把vector定义中一些比较关键的定义展示出来了，本来想写一下这个迭代器的，发现下一节讲的就是迭代器，不过看了这些个定义，还是对vector的使用有很大好处的，至少知道原来那么写那么用的原理的是什么。反正这个是自己看书上的代码。

## 三.vector的迭代器

在上面的定义摘要中我们也可以看到vector的迭代器其实就是T*，因为vecotr和array数据安排和操作方式都很类似，所以用原生指针作为vector的迭代器就OK了，至于iterator_traits和__type_traits就是直接用的特化版本的。

## 四.vector的数据结构

vector的数据结构就是最简单的线性连续空间，这里要注意的就是vector的容量问题，容量不是vector的当前大小，而是vector的总空间大小，如果容量不够了，则vector会经过重新配置，元素移动，释放原空间等系列工作将配置扩充至两倍或更大。

## 五.vecotr的构造与内存管理

vector的构造函数有很多，这个就不一一说明了，关键是vector的内存管理，即初始分配内存，释放内存，还有空间不够时配置新的空间。这里面最关键的是空间不够时配置新的空间。

（配置新空间里面有几个不懂的地方可能要看到下一节insert函数才懂），首先是在push_back里面，如果空间不够了，就调用insert_aux函数，如果还有空间直接配置即可，如果没有空间了就要找到新的空间，一般是两倍与原来的空间，然后把原来的对象复制过来，把原来的对象析构了（其实因为vector这里面迭代器用的就是原生指针，析构啥事也不做），把原来的空间释放了（注意，destroy是析构对象，并没有释放空间，要用dellocate来释放空间），然后把start和finish以及end_of_storage重新定位即可。

注意，这里在使用的时候就有一个易错点，因为这里是重新配置的空间，所以之前的指针就不管用了，加入之前我们让一个指针（或者说迭代器）指向vector的开头（通过复制first），那现在它指向的那个空间已经无意义了，再使用就会出错。

补充：insert_aux函数有可能被当做insert函数调用，所以里面对空间的分配也要考虑insert操作，所以用insert操作的逻辑去看里面的一些操作就懂了。

## 六.vector的元素操作

pop_back()：就简单的finish前移和析构。

erase()：清楚所有元素，注意vector是线性排列的数据，所以erase中要保持数据线性排列，所以直接copy覆盖掉要erase的数据即可。

insert()：首先是空间还够的情况下，又分两种情况，这里分两种情况主要是为了提高效率（但是我不知道怎么就提升效率了），然后就是空间不够的情况下，和insert_aux的操作差不多，只不过这里插入的是多个数据而已。

## 七.小结

vector是存储线性数据关系且有动态空间的容器，迭代器为原生指针，有多种构造函数，还包括insert,pop_back,push_back,erase等一系列操作。vector最关键在于动态空间，而动态空间的保证在于一旦容量用尽，就重新配置一个更大的空间以存储原来的数据，重新配置的这个空间与原来的空间没有关系，原来的指针不能再用。涉及空间的操作有一点点绕，可以结合着图或者自己画个图来理解。