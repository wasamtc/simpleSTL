# list

## 一.list概述

list类似于双向链表，同vector相比，list每次插入或删除元素都分配或释放相应的空间，且元素的插入与删除是常数时间。

## 二.list的结点

list本身和list的结点是不同的结构，list的结点有一个前驱指针，一个后驱指针，一个数据域。

## 三.list的迭代器

list的迭代器必须自主设计，不能像vector那样用原生指针作为迭代器，因为list的空间并不一定连续。

list的迭代器设计并不复杂，差不多就是内部有一个指向node的指针，然后通过操作符重载是整个迭代器具有迭代器的性质（递增，递减，取值，成员存取）。

这里要说一下这个成员存取（其实我一直不太清楚这个操作符重载的原理），这个成员存取的操作符重载函数返回的是一个指针，我们可以通过这个函数（或者说->）去存取该指针指向的对象的成员，从这句话也可以看出，指针指向的对象必须是一个class  type。（而且原生指针本身就有->操作）

## 四.list的数据结构

SGI list不仅是一个双向链表，还是一个环状双向链表，只需要一个指针便可完成这个链表的遍历，而且STL中的容器要符合前闭后开的原则，所有让node指向尾端的一个空白结点，然后再实现begin，end，empty，size，front，back等函数。

## 五.list的构造与内存管理

list有专门的函数配置或释放一个结点的大小，而析构构造函数都是针对结点里面的data而言，也就是说，总的create_node是先配置空间，再用construct构造data，插入的时候也可以看出了，传入的类型是T而不是结点。

还有一点，为什么说list的插入删除是常数时间呢，因为在插入删除前用find函数找到了要操作的结点的位置，后面的操作当然就是常数时间了。

## 六.list的元素操作

这一节没什么好说的，直接看代码就行。不过要注意list和vector的区别，而且list的迭代器不能说是指向的结点，只能说是对结点指针的一个封装，没有完全的指针功能，而且list的操作挺多的，这上面介绍的也不完全。

关于list的排序：[STL库list::sort()实现深度解析](http://www.cnblogs.com/avota/p/5388865.html)

## 七.小结

list是一个环状双向链表，迭代器不同与vector，是自身实现的，也有许多相应的操作，list的特点其实就是环状双向链表的特点，插入删除是常数时间。

